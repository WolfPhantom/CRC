# -*- coding: utf-8 -*-
"""Redes-TF.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Czu0DCd2zYxsldQhEHUVhifY6OCKml3K
"""

import numpy as np
import pandas as pd




#El polinomio en esa caja proporcionará la mejor HD posible en esa longitud y tamaño de CRC
def SearchGoodPolynomian(data,l,CRCSize, length):
    print(CRCSize,length)
    columns = data.columns.values
    t = data.shape[0]
    mm = []
    for i in range(t):
        #for j in range(1,len(l)):
        if df[columns[l[1]]][i] == CRCSize and df[columns[l[0]]][i] >= length:
            #print(df.loc[i])
            mm.append(i)
    print("Lista me mejores polinomios: ", mm)
    print("Polinomio optimo a un tamaño de CRC ", CRCSize, " y de tamaño de trama ", length, " ")
    print(df.loc[max(mm)])
    return df.loc[min(mm)][0]

#Este es el CRC más pequeño que puede proporcionar el HD deseado con la longitud requerida
def FindMinimumSizeCRC(data,l,HD, length):
    print(HD,length)
    columns = data.columns.values
    t = data.shape[0]
    mm = []
    for i in range(t):
        #for j in range(1,len(l)):
        if df[columns[l[2]]][i] == HD and df[columns[l[0]]][i] >= length:
            #print(df.loc[i])
            mm.append(i)
    print("Lista me mejores polinomios: ", mm)
    print("Polinomio optimo a un tamaño de CRC ", df.loc[min(mm)][2], " y de tamaño de trama ", length, " ")
    print(df.loc[min(mm)])
    return df.loc[min(mm)][0]

#Consulta xor
def xor(a, b): 
   
    # Resultado 
    result = [] 
   
    # comparativa xor
    for i in range(1, len(b)): 
        if a[i] == b[i]: 
            result.append('0') 
        else: 
            result.append('1') 
   
    return ''.join(result) 
   
   
#Devuelve el residuo de la division xor
def CRC(divident, divisor): 
   
    
    #Numero de bits que se comparan a la vez 
    pick = len(divisor) 
   
    # el dividendo a la longitud apropiada para su uso
    tmp = divident[0 : pick] 
   
    while pick < len(divident): 
   
        if tmp[0] == '1': 
   
            #reemplace el dividendo por el resultado de XOR y tire 1 bit hacia abajo
            tmp = xor(divisor, tmp) + divident[pick] 
   
        else:    
            tmp = xor('0'*pick, tmp) + divident[pick] 
   
         
        pick += 1
   
   
    if tmp[0] == '1': 
        tmp = xor(divisor, tmp) 
    else: 
        tmp = xor('0'*pick, tmp) 
   
    checkword = tmp 
    return checkword 
   
# Función utilizada en el lado del remitente para codificar datos agregando el resto de la división modular al final de los datos.
def encodeData(data, key): 
   
    l_key = len(key) 
   
    # Agregar n-1 ceros al final de la data 
    appended_data = data + '0'*(l_key-1) 
    remainder = CRC(appended_data, key) 
   
    # 
    #Agregar resto en la data original
    codeword = data + remainder 
    return codeword 

def decodeData(data, key): 
   
    l_key = len(key) 
    appended_data = data + '0'*(l_key-1) 
    remainder = CRC(appended_data, key) 
   
    return remainder 
#Consulta por la forma binaria del polinomio escogido
def binaryPoli(poli):
  index=dfPolinomios[dfPolinomios['Polinomio']==poli].index.values.astype(int)[0]
  key1=str(dfPolinomios.at[index,'Binario'])
  return key1

df = pd.read_csv("datatf.csv")
df.columns = ['Polynomial','Length','CRCSize','MaxLengthHD']
dfPolinomios = pd.read_csv("Polinomios.csv")
l = [1,2,3]

print("Ingrese consulta deseada")
print("(1) CRC SIZE deseado")
print("(2) HD deseado")
op=input("opcion ->")
print(op)


if op=='1':
  input_string = input("Ingrese mesenja ->") 
  data =(''.join(format(ord(x), 'b') for x in input_string)) 
  print (len(data)) 
  CRCs = input("Ingrese longitud del CRC SIZE deseado->")
  poli=SearchGoodPolynomian(df,l, int(CRCs),len(data))

elif op=='2':
  input_string = input("Ingrese mesenja ->") 
  data =(''.join(format(ord(x), 'b') for x in input_string)) 
  print (len(data)) 
  HD = input("Ingrese longitud del HD deseado->")
  poli=FindMinimumSizeCRC(df,l, int(HD),len(data))

print(poli)
key1=binaryPoli(poli)
ans = encodeData(data,key1) 
print("Data enviada: "+ans) 

ans = decodeData(ans, key1)
print("Residuo del receptor: "+ans)

1
1